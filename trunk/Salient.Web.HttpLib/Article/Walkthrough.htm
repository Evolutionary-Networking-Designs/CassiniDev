<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
<head>
    <title>HttpLib walkthrough</title>
    <style type="text/css">
    html{font-family:Sans-Serif;}
    </style>
</head>
<body>
<h4>Retain your sanity! Quickly and easily write test suites for your Ajax/REST/Form/Upload/other http endpoints.</h4>
<h2>Overview</h2>
<p>In this post I will introduce you to a small library, <code>Salient.Web.HttpLib</code>, that is designed primarily to support the testing of Http endpoints. </p>
<p>Special attention is paid to the concerns of testing MS Ajax/WCF/WebServices endpoints and the primary focus of the tests will be centered on Ajax-enabled WCF service, static .aspx PageMethods and Xml WebServices that have been decorated with <code>[ScriptService]</code> or <code>[ScriptMethod]</code> attributes all demonstrate the same behavior and will hereafter referred to collectively as 'JSON endpoints'.</p>
<p>Other endpoints/platforms can easily be consumed and following the walkthrough, applying the patterns demonstrated against other targets will be academic.</p>
<p>The walkthrough will be accomplished by detailed description of actual passing tests contained in the attached VS2008 solution.</p>
<p>The walkthough tests are contained in <code>ArticleSiteFixture</code> which is derived from <code>Salient.Web.HttpLib.WebDevFixture</code>.</p>
<p>This test fixture contains methods that simulate the type of requests that are to be expected from our client script. This allows for automated testing of our endpoints from the perspective of client script.</p>
<p>Note: consider yourself warned: In the spirit of the JavaScript client we are going to be simulating, I will be abusing closures, anonymous methods and types with impunity and glee. ;-)</p>
<p>You can call this functional testing or smoke testing or maybe even integration testing, just don't call it unit testing.</p>
<h2>Walkthrough</h2>
<p><strong>Salient.Web.HttpLib.WebDevFixture</strong></p>
<p><code>WebDevFixture</code> encapsulates a controlled startup of Visual Studio's development server. To spin up an instance of WebDev, simply supply an unused port and the physical path to the site. This can be a relative path enabling portable tests.</p>
<p><code>WebDevFixture</code> provides a convenience method, .NormalizeUri(), that will normalize, or root, a relative path and query string to the root of the current site.</p>
<p>For more information see 
    <a target="_blank" href="http://www.codeproject.com/Articles/72222/A-general-purpose-Visual-Studio-2008-Development-S.aspx">
    http://www.codeproject.com/Articles/72222/A-general-purpose-Visual-Studio-2008-Development-S.aspx</a>.</p>
<p>For more finely tuned control of a testing server you should check out 
    <a target="_blank" href="http://cassinidev.codeplex.com/">http://cassinidev.codeplex.com/</a></p>
<p>This example demonstrates use of <code>WebDevFixture</code> with NUnit but any testing framework can be used with ease.</p>
<p>&nbsp;</p>
<h3>ArticleSiteFixture</h3>
<pre class="brush:c#;">[TestFixture]
public class ArticleSiteFixture : WebDevFixture
{
    protected override int Port
    {
        get { return 12334; }
    }

    [TestFixtureSetUp]
    public void TestFixtureSetUp()
    {
        // the relative physical path of the site we want to test
        var path = Path.GetFullPath(@&quot;..\..\..\HttpLibArticleSite&quot;);

        StartServer(path);
    }

    /*
     * 
     *  insert interesting tests go here
     * 
     */

}
</pre>
<p>&nbsp;</p>
<h3>Deserializing MS Ajax Wrapped JSON</h3>
<p>The default format for a JSON endpoint response JSON is a 'd: wrapped' object. There are some configuration options and attributes that can modify this behavior, but this default behavior is also the worst case scenario so lets deal with it straight away.</p>
<p>An example that we will be dealing with is the simple <code>Result</code> class defined in the demo site. When returned as JSON it looks like this:</p>
<p><code>{&quot;d&quot;:{&quot;__type&quot;:&quot;Result:#HttpLibArticleSite&quot;,&quot;Message&quot;:&quot;Value pull OK.&quot;,&quot;Session&quot;:&quot;rmyykw45zbkxxxzdun0juyfr&quot;,&quot;Value&quot;:&quot;foo&quot;}}</code></p>
<p>Deserializing JSON of this format can be problematic but I have provided an extension method for <code>JavaScriptSerializer</code> that will handle this type of JSON. You can read about it in detail here: <a target="_blank" href="http://www.codeproject.com/KB/aspnet/Parsing-ClientScript-JSON.aspx">http://www.codeproject.com/KB/aspnet/Parsing-ClientScript-JSON.aspx</a></p>
<p>The short story is that <code>ClientScriptUtilities</code> provides a <code>JavaScriptSerializer</code> extension method, <code>.CleanAndDeserialize&lt;T&gt;()</code>, that will extract the inner object and clean the <code>&quot;__type&quot;</code> properties before deserializing it. The JSON that is ultimately serialized looks like this:</p>
<p><code>{&quot;Message&quot;:&quot;Value pull OK.&quot;,&quot;Session&quot;:&quot;rmyykw45zbkxxxzdun0juyfr&quot;,&quot;Value&quot;:&quot;foo&quot;}</code></p>
<p><code>CleanAndDeserialize</code> also supports deserialization to anonymous types.</p>
<p>NOTE: <code>CleanAndDeserialize</code> does not require ugly MsAjax JSON. It will consume any valid JSON so this is a safe replacement for <code>.Deserialize&lt;T&gt;</code> throughout your code regardless of the JSON format.</p>
<pre class="brush:c#;">  [Test]
  public void Deserializing_MS_Ajax_Wrapped_JSON()
  {
      JavaScriptSerializer jsSerializer = new JavaScriptSerializer();


      // simulate a typical JSON response
      const string responseText =
          &quot;{\&quot;d\&quot;:{\&quot;__type\&quot;:\&quot;Result:#HttpLibArticleSite\&quot;,\&quot;Message\&quot;:\&quot;Value pull OK.\&quot;,\&quot;Session\&quot;:\&quot;rmyykw45zbkxxxzdun0juyfr\&quot;,\&quot;Value\&quot;:\&quot;foo\&quot;}}&quot;;

      Result result = jsSerializer.CleanAndDeserialize&lt;Result&gt;(responseText);

      Assert.AreEqual(&quot;rmyykw45zbkxxxzdun0juyfr&quot;, result.Session);

      var resultPrototype = new
          {
              Message = default(string),
              Value = default(string)

          };

      var anonymousResultSubset = jsSerializer.CleanAndDeserialize(responseText, resultPrototype);

      Assert.AreEqual(&quot;foo&quot;, anonymousResultSubset.Value);

  }
</pre>
<h3>Exception Handling</h3>
<p>When an endpoint of any kind throws an exception it is ultimately swallowed by a generic '500 Internal Server Error' WebException. </p>
<p>Discovering the actual underlying exception can be quite tedious, involving parsing of the <code>WebException.Response.GetResponseStream()</code> and determining whether it is a JsonFaultDetail from a JSON endpoint, an ASP.Net Yellow Screen of death or a number of other formats.</p>
<p><code>WebRequestException</code> encapsulates all of this behavior and surfaces the salient information, if available. The original <code>WebException</code> is availabe on the <code>InnerException</code> property.</p>
<pre class="brush:c#;">  [Test]
  public void Exception_Handling()
  {

      try
      {
          RequestFactory.CreatePostJsonApp(NormalizeUri(&quot;AjaxService.svc/ThrowException&quot;)).GetResponse();
          Assert.Fail(&quot;Expected WebException&quot;);
      }
      catch (WebException ex)
      {
          WebRequestException ex2 = WebRequestException.Create(ex);
          Console.WriteLine(&quot;Caught {0}: {1}&quot;, ex2.ExceptionDetail.ExceptionType, ex2.Message);
      }
  }

</pre>
<h3>RequestFactory.CreateRequest</h3>
<p><code>RequestFactory.CreateRequest</code> is the base method that all of the specialized factory method overloads ultimately call. </p>
<p>With a basic understanding of this method, all of the specialized overloads will be readily understandable.</p>
<p><code>RequestFactory.CreateRequest</code> builds up an <code>HttpWebRequest</code>, applying the supplied arguments appropriately and returns it. You are then free to manipulate the request as you choose before executing the request. This pattern is applied over all of the various overloads.</p>
<p><strong>Arguments</strong></p>
<ul>
    <li><code><strong>requestUri</strong> - Uri or String</code><br />
    Absolute Uri of resource<br />
    </li>
    <li><code><strong>method</strong> - HttpMethod</code><br />
    The http method of the request. Currently supported options are <code>HttpMethod.Post</code> and <code>HttpMethod.Get</code><br />
    </li>
    <li><code><strong>contentType</strong> - ContentType</code><br />
    The content-type of the request. Currently supported options are <code>ContentType.None</code>, <code>ContentType.ApplicationForm</code>, <code>ContentType.ApplicationJson</code> and <code>ContentType.TextJson</code><br />
    </li>
    <li><code><strong>postData</strong> - object</code><br />
    Optional. A <code>NameValueCollection</code> or <code>object</code>. Anonymous types are acceptable. <br />
    <br />
    The object will be serialized appropriately for the request method and content-type before being applied to the request.<br />
    <br />
    Note: any object that is shaped like the target method's arguments is acceptable. Conveniently this includes anonymous types. <br />
    <br />
    For a 'Get' or form 'Post' a <code>NameValueCollection</code> may be appropriate as it is able to accept multiple values for a single key to fully simulate the possible shape of a form. <br />
    <br />
    When creating anonymous types as input parameters, you are not required to prototype the target type exactly. You MUST prototype non-nullable properties, including value types and structs, but you may omit any nullable properties, including <code>Nullable&lt;T&gt;</code> and reference types, that you do not need to send.<br />
    <br />
    An anonymous type suitable as postData for the method <code>public Result PutSessionVar(string input)</code> would be <code>var postData = new { input = &quot;foo&quot; };</code><br />
    <br />
    An anonymous type suitable as postData for the method <code>public Result PutSessionVar(Result input)</code> would be <br />
    <code>var postData = new { input = new Result() };</code> or <br />
    <code>var postData = new { input = new { Message = &quot;message&quot;, Session = &quot;session&quot;, Value = &quot;value&quot; } };</code> or <br />
    <code>var postData = new { input = new { Message = &quot;message&quot; } };</code><br />
    
    <ul>
        <li>For form 'Post' requests, the postData object will be serialized into a Url encoded key-value string an streamed into the request body. </li>
        <li>For a JSON 'Post', it will be JSON serialized and streamed into the request body. </li>
        <li>For a 'Get' request it will be Url encoded into a query string and intelligently appended to the Uri. If the Uri is bare, the query string will be appended with a '?'. If the Uri already has a query string the new query will be appended with a '&amp;'.<br />
        </li>
    </ul>
    </li>
    <li><code><strong>cookies</strong> - CookieCollection</code><br />
    Optional. Sharing a <code>CookieCollection</code> between requests is required to maintain session state, FormsAuthentication tickets and other cookies.<br />
    </li>
    <li><code><strong>headers</strong> - NameValueCollection</code><br />
    Optional. Http headers to be added to the request.</li>
</ul>
<p><code>StreamExtensions</code> provide two simple convenience extensions for use with the response stream.</p>
<ul>
    <li><code>Stream.TextStream.Text()</code> will extract the stream into an UTF-8 string.</li>
    <li><code>Stream.Bytes()</code> will extract the stream into a byte array.</li>
</ul>
<pre class="brush:c#;">  [Test]
  public void Using_CreateRequest()
  {

      // Required arguments:
      Uri uri = NormalizeUri(&quot;AjaxService.svc/PutSessionVar&quot;);
      const HttpMethod method = HttpMethod.Post;
      const ContentType contentType = ContentType.ApplicationJson;
      // Optional arguments:


      // This is the method we will be calling - public Result PutSessionVar(string input)
      // Lets create an anonymous type shaped like the method signature...
      var postData = new { input = &quot;foo&quot; };

      CookieContainer cookies = new CookieContainer();

      // Add a useful header...
      NameValueCollection headers = new NameValueCollection { { &quot;x-foo-header&quot;, &quot;bar-value&quot; } };

      // With the arguments defined, create the request
      HttpWebRequest request = RequestFactory.CreateRequest(uri, method, contentType, postData, cookies, headers);

      // If you are not concerned with immediate disposal of the response stream, 
      // you can retrieve the response with a single expression like so
      var responseText = request.GetResponse().GetResponseStream().Text();


      // thats it for the basic usage.





      // we are going to pick up the pace a bit and demonstrate a few usage patterns so lets declare an anonymous 
      // inline factory method to create our requests from this point on.

      Func&lt;HttpWebRequest&gt; createRequest = () =&gt; RequestFactory.CreateRequest(uri, method, contentType, postData, cookies, headers);


      using (Stream responseStream = createRequest().GetResponse().GetResponseStream())
      {
          var rtext = responseStream.Text();
      }


      // It is recommended that you wrap requests using the exception handling pattern previously described
      // even if you are just going to re-throw

      try
      {
          using (Stream responseStream = createRequest().GetResponse().GetResponseStream())
          {
              var rtext = responseStream.Text();
          }
      }
      catch (WebException ex)
      {
          WebRequestException wrex = WebRequestException.Create(ex);
          // Now either try to handle it or re-throw

          throw wrex;
          // we reset the stack trace but a WebRequestException has but one source so this is not an issue.
      }


      // Now if we throw the deserialization into the mix things start coming together.

      JavaScriptSerializer jsSerializer = new JavaScriptSerializer();

      try
      {
          using (Stream responseStream = createRequest().GetResponse().GetResponseStream())
          {
              Result result1 = jsSerializer.CleanAndDeserialize&lt;Result&gt;(responseStream.Text());
              Assert.AreEqual(&quot;foo&quot;, result1.Value);
          }
      }
      catch (WebException ex)
      {
          WebRequestException wrex = WebRequestException.Create(ex);
          throw wrex;
      }




      // Using an anonymous prototype for the response

      try
      {
          using (Stream responseStream = createRequest().GetResponse().GetResponseStream())
          {
              var resultPrototype = new
                  {
                      Value = default(string),
                      Session = default(string)
                  };

              var result2 = jsSerializer.CleanAndDeserialize(responseStream.Text(), resultPrototype);

              Assert.AreEqual(&quot;foo&quot;, result2.Value);
          }
      }
      catch (WebException ex)
      {
          WebRequestException wrex = WebRequestException.Create(ex);
          throw wrex;
      }




      // For those who like to live dangerously the whole process can be executed in one statement 
      // Do not try this at home. ;-)

      CookieContainer existingCookies = new CookieContainer();

      var result3 = jsSerializer.CleanAndDeserialize(
          RequestFactory.CreateRequest(NormalizeUri(&quot;AjaxService.svc/PutSessionVar&quot;), HttpMethod.Post, ContentType.ApplicationJson,
          new { input = &quot;foo&quot; }, existingCookies, new NameValueCollection { { &quot;x-foo-header&quot;, &quot;bar-value&quot; } }).
          GetResponse().GetResponseStream().Text(), new { Value = default(string) });
      Assert.AreEqual(&quot;foo&quot;, result3.Value);

      // interesting as this treatment may be, I think you would have to be mad to apply it. 

  }
</pre>
<p>Now, with a basic understanding of the base <code>.CreateRequest()</code> method, lets refactor to reduce code bloat and centralize our JSON response execution pattern in a few generic methods.</p>
<pre class="brush:c#;">   /// &lt;summary&gt;
  /// &lt;/summary&gt;
  /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
  /// &lt;param name=&quot;request&quot;&gt;&lt;/param&gt;
  /// &lt;param name=&quot;handler&quot;&gt;If null, created WebRequestException is thrown when GetReponse craps out.&lt;/param&gt;
  /// &lt;returns&gt;&lt;/returns&gt;
  public T GetJsonResponse&lt;T&gt;(HttpWebRequest request, Action&lt;WebRequestException&gt; handler)
  {
      JavaScriptSerializer jsSerializer = new JavaScriptSerializer();
      try
      {
          using (Stream responseStream = request.GetResponse().GetResponseStream())
          {

              return jsSerializer.CleanAndDeserialize&lt;T&gt;(responseStream.Text());
          }
      }
      catch (WebException ex)
      {
          WebRequestException reqEx = WebRequestException.Create(ex);
          if (handler != null)
          {
              handler(reqEx);
              return default(T);
          }

          throw reqEx;
      }
  }

  /// &lt;summary&gt;
  /// And for anonymous response types....
  /// &lt;/summary&gt;
  /// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
  /// &lt;param name=&quot;request&quot;&gt;&lt;/param&gt;
  /// &lt;param name=&quot;prototype&quot;&gt;&lt;/param&gt;
  /// &lt;param name=&quot;handler&quot;&gt;If null, created WebRequestException is thrown when GetReponse craps out.&lt;/param&gt;
  /// &lt;returns&gt;&lt;/returns&gt;
  public T GetJsonResponse&lt;T&gt;(HttpWebRequest request, T prototype, Action&lt;WebRequestException&gt; handler)
  {
      JavaScriptSerializer jsSerializer = new JavaScriptSerializer();
      try
      {
          using (Stream responseStream = request.GetResponse().GetResponseStream())
          {

              return jsSerializer.CleanAndDeserialize(responseStream.Text(), prototype);
          }
      }
      catch (WebException ex)
      {
          WebRequestException reqEx = WebRequestException.Create(ex);
          if (handler != null)
          {
              handler(reqEx);
              return default(T);
          }

          throw reqEx;
      }
  }



  /// &lt;summary&gt;
  /// Test the utility methods.
  /// &lt;/summary&gt;
  [Test]
  public void Using_Utility_Methods()
  {
      // We have already seen how to build up a request from parts, so for the sake of 
      // brevity (and being clever) lets define an inline factory method.

      Func&lt;HttpWebRequest&gt; createRequest = () =&gt; RequestFactory.CreateRequest(
          NormalizeUri(&quot;AjaxService.svc/PutSessionVar&quot;), HttpMethod.Post, ContentType.TextJson, new { input = &quot;foo&quot; }, null, null);

      // As an added bit of abuse, an anonymous exception handler to pass to the generic utility methods

      Action&lt;WebRequestException&gt; commonExceptionHandler = up =&gt;
                      {

                          Console.WriteLine(&quot;Inside inline shared exception handler&quot;);
                          // handle ex if possible, and return, otherwise throw 


                          throw up; // ;-O~~
                      };


      // Call a valid method with referenced response type. commonExceptionHandler will not be executed
      Result result = GetJsonResponse&lt;Result&gt;(createRequest(), commonExceptionHandler);

      Assert.AreEqual(&quot;foo&quot;, result.Value);


      // Call a valid method with an anonymous response type. commonExceptionHandler will not be executed
      var anonResult = GetJsonResponse(createRequest(), new { Value = default(string) }, commonExceptionHandler);

      Assert.AreEqual(&quot;foo&quot;, anonResult.Value);

      // Test the generic GetJsonResponse with an exception and a handler, . commonExceptionHandler WILL executed
      try
      {
          GetJsonResponse(RequestFactory.CreatePostJsonApp(NormalizeUri(&quot;AjaxService.svc/ThrowException&quot;)), new { Value = default(string) }, commonExceptionHandler);
          Assert.Fail(&quot;Expected WebRequestException&quot;);
      }
      catch (WebRequestException)
      {

          Console.WriteLine(&quot;Handler works&quot;);
      }

      // test the generic GetJsonResponse with an exception and no handler. commonExceptionHandler is null and will NOT be executed
      try
      {
          GetJsonResponse(RequestFactory.CreatePostJsonApp(NormalizeUri(&quot;AjaxService.svc/ThrowException&quot;)), new { Value = default(string) }, null);
          Assert.Fail(&quot;Expected WebRequestException&quot;);
      }
      catch (WebRequestException)
      {

          Console.WriteLine(&quot;WebRequestException was thrown from GetJsonResponse as no handler was specified&quot;);
      }
  } 
</pre>
<h3>Overloads</h3>
<p>Now lets take the time for a brief overview of the available overloads of <code>CreateRequest</code> before we start drilling down into <code>.CreatePostJsonApp()</code>.</p>
<p>All overloads accept a <code>string</code> or <code>Uri</code> for <code>requestUri</code>.</p>
<p>There is a specialized <code>RequestFactory.CreateFilePost()</code> method for uploading files that has it's own unique but similar API that will be covered at the end of this walkthrough.</p>
<pre class="brush:c#;">  /// &lt;summary&gt;
  /// Creates a request using http 'Get' and ContentType.None. PostData is Url-encoded and appended to the Uri.
  /// &lt;/summary&gt;
  [Test]
  public void CreateGet_Overloads()
  {
      Uri requestUri = NormalizeUri(&quot;Default.aspx&quot;);

      CookieContainer cookies = new CookieContainer();
      NameValueCollection headers = new NameValueCollection();

      // postData could also be an object or anonymous type
      NameValueCollection postData = new NameValueCollection();


      // get overloads
      RequestFactory.CreateGet(requestUri)
          .GetResponse().GetResponseStream().Text();

      RequestFactory.CreateGet(requestUri, postData)
          .GetResponse().GetResponseStream().Text();

      RequestFactory.CreateGet(requestUri, postData, cookies)
          .GetResponse().GetResponseStream().Text();

      RequestFactory.CreateGet(requestUri, postData, cookies, headers)
          .GetResponse().GetResponseStream().Text();
  }

  /// &lt;summary&gt;
  /// Creates a request using http 'Get' and ContentType.ApplicationJson. PostData is Url-encoded and appended to the Uri.
  /// &lt;/summary&gt;
  [Test]
  public void CreateGetJsonApp_Overloads()
  {
      Uri requestUri = NormalizeUri(&quot;Default.aspx&quot;);

      CookieContainer cookies = new CookieContainer();
      NameValueCollection headers = new NameValueCollection();

      // postData could also be an object or anonymous type
      NameValueCollection postData = new NameValueCollection();

      RequestFactory.CreateGetJsonApp(requestUri)
          .GetResponse().GetResponseStream().Text();

      RequestFactory.CreateGetJsonApp(requestUri, postData)
          .GetResponse().GetResponseStream().Text();

      RequestFactory.CreateGetJsonApp(requestUri, postData, cookies)
          .GetResponse().GetResponseStream().Text();

      RequestFactory.CreateGetJsonApp(requestUri, postData, cookies, headers)
          .GetResponse().GetResponseStream().Text();
  }

  /// &lt;summary&gt;
  /// Creates a request using http 'Get' and ContentType.TextJson. PostData is Url-encoded and appended to the Uri.
  /// &lt;/summary&gt;
  [Test]
  public void CreateGetJsonText_Overloads()
  {
      Uri requestUri = NormalizeUri(&quot;Default.aspx&quot;);

      CookieContainer cookies = new CookieContainer();
      NameValueCollection headers = new NameValueCollection();

      // postData could also be an object or anonymous type
      NameValueCollection postData = new NameValueCollection();

      RequestFactory.CreateGetJsonText(requestUri)
          .GetResponse().GetResponseStream().Text();

      RequestFactory.CreateGetJsonText(requestUri, postData)
          .GetResponse().GetResponseStream().Text();

      RequestFactory.CreateGetJsonText(requestUri, postData, cookies)
          .GetResponse().GetResponseStream().Text();

      RequestFactory.CreateGetJsonText(requestUri, postData, cookies, headers)
          .GetResponse().GetResponseStream().Text();
  }

  /// &lt;summary&gt;
  /// Creates a request using http 'Post' and ContentType.ApplicationForm. PostData is Url-encoded and written to the request body.
  /// &lt;/summary&gt;
  [Test]
  public void CreatePostForm_Overloads()
  {
      Uri requestUri = NormalizeUri(&quot;Default.aspx&quot;);

      CookieContainer cookies = new CookieContainer();
      NameValueCollection headers = new NameValueCollection();

      // postData could also be an object or anonymous type
      NameValueCollection postData = new NameValueCollection();

      RequestFactory.CreatePostForm(requestUri)
          .GetResponse().GetResponseStream().Text(); ;

      RequestFactory.CreatePostForm(requestUri, postData)
          .GetResponse().GetResponseStream().Text(); ;

      RequestFactory.CreatePostForm(requestUri, postData, cookies)
          .GetResponse().GetResponseStream().Text();

      RequestFactory.CreatePostForm(requestUri, postData, cookies, headers)
          .GetResponse().GetResponseStream().Text();
  }

  /// &lt;summary&gt;
  /// Creates a request using http 'Post' and ContentType.ApplicationJson. PostData is JSON-encoded and written to the request body.
  /// This overload is most appropriate for posting to MS JSON endpoints an the rest of the functional examples will use
  /// this overload.
  /// &lt;/summary&gt;
  [Test]
  public void CreatePostJsonApp_Overloads()
  {
      Uri requestUriNoArgs = NormalizeUri(&quot;AjaxService.svc/Noop&quot;);
      Uri requestUri = NormalizeUri(&quot;AjaxService.svc/PutSessionVar&quot;);

      CookieContainer cookies = new CookieContainer();
      NameValueCollection headers = new NameValueCollection();

      // postData could also be an object or a NameValueCollection
      object postData = new { input = &quot;foo&quot; };

      RequestFactory.CreatePostJsonApp(requestUriNoArgs)
          .GetResponse().GetResponseStream().Text();

      RequestFactory.CreatePostJsonApp(requestUri, postData)
          .GetResponse().GetResponseStream().Text();

      RequestFactory.CreatePostJsonApp(requestUri, postData, cookies)
          .GetResponse().GetResponseStream().Text();

      RequestFactory.CreatePostJsonApp(requestUri, postData, cookies, headers)
          .GetResponse().GetResponseStream().Text();
  }

  /// &lt;summary&gt;
  /// Creates a request using http 'Post' and ContentType.TextJson. PostData is JSON-encoded and written to the request body.
  /// &lt;/summary&gt;
  [Test]
  public void CreatePostJsonText_Overloads()
  {
      Uri requestUriNoArgs = NormalizeUri(&quot;AjaxService.svc/Noop&quot;);
      Uri requestUri = NormalizeUri(&quot;AjaxService.svc/PutSessionVar&quot;);

      CookieContainer cookies = new CookieContainer();
      NameValueCollection headers = new NameValueCollection();

      // postData could also be an object or a NameValueCollection
      object postData = new { input = &quot;foo&quot; };

      RequestFactory.CreatePostJsonText(requestUriNoArgs)
          .GetResponse().GetResponseStream().Text();

      RequestFactory.CreatePostJsonText(requestUri, postData)
          .GetResponse().GetResponseStream().Text();

      RequestFactory.CreatePostJsonApp(requestUri, postData, cookies)
          .GetResponse().GetResponseStream().Text();

      RequestFactory.CreatePostJsonText(requestUri, postData, cookies, headers)
          .GetResponse().GetResponseStream().Text();
  }

</pre>
<h3>Using CreatePostJsonApp With JSON Endpoints</h3>
<p>All of the overloads resolve to the base <code>.CreateRequest()</code> methods thus follow the same pattern. The focus of this walkthrough is testing MS JSON endpoints, so we are going to focus on the <code>.CreatePostJsonApp()</code> method.</p>
<p>Most other scenarios such as posting to a standard form and consuming a non MS REST service can be serviced in like fashion using the other overloads.</p>
<p>So, simulating an <code>XMLHttpRequest</code> that would be used to consume an ms JSON endpoint is accomplished using <code>CreatePostJsonApp()</code>.</p>
<p>In this example, in order to demonstrate the direct parity between the three types of JSON endpoints we have created 3 endpoints, an Ajax-enabled WCF service, A WebServices decorated with [ScriptService] and static .aspx methods decorated with [WebMethod] (PageMethods), each with a similar API.</p>
<p>We will call each of these endpoints using identical code from within a loop and witness identical behavior.</p>
<p>Note: in previous listings, various generic utility methods and inline factory strategies have been presented. You may find these patterns useful but, for the sake of clarity, the rest of this walk through will use expanded syntax.</p>
<pre class="brush:c#;">  [Test]
    public void Using_RequestFactory_CreatePostJsonApp_With_Json_Endpoints()
    {
        JavaScriptSerializer jsSerializer = new JavaScriptSerializer();

        // the methods will be calling looks like this:

        // public string PutSessionVar(string input)
        // public Result GetSessionVar()


        // parameters can be defined with anonymous types. 
        var postData = new { input = &quot;foo&quot; };

        // we will simply call API equivalent instances of each endpoint with the same code.
        string[] jsonEndpoints = new[] { &quot;AjaxService.svc&quot;, &quot;ScriptService.asmx&quot;, &quot;Default.aspx&quot; };

        foreach (string address in jsonEndpoints)
        {
            try
            {
                using (var response = RequestFactory.CreatePostJsonApp(NormalizeUri(address + &quot;/PutSessionVar&quot;), postData).GetResponse().GetResponseStream())
                {
                    Result result = jsSerializer.CleanAndDeserialize<result></result>(response.Text());
                    Assert.AreEqual(&quot;foo&quot;, result.Value);
                }

                // now lets get the value

                try // this try/catch is a bit of a spoiler but bear with me
                {
                    RequestFactory.CreatePostJsonApp(NormalizeUri(address + &quot;/GetSessionVar&quot;)).GetResponse().GetResponseStream();
                    Assert.Fail(&quot;Expected WebException&quot;);
                }
                catch (WebException ex)
                {
                    // as you can see, the value was not found in the session because we don't have a cookie
                    // container to share between requests
                    WebRequestException ex2 = WebRequestException.Create(ex);
                    Console.WriteLine(&quot;Caught {0}: {1}&quot;, ex2.ExceptionDetail.ExceptionType, ex2.Message);

                }
            }
            catch (Exception ex)
            {
                Assert.Fail(&quot;Endpoint {0} failed with {1}&quot;, address, ex.Message);
            }
        }

        // Which brings us to the overload of .CreatePostJsonApp that accepts a CookieContainer as an argument....

    }

</pre>
<p>To maintain Session State, FormsAuthentication and other cookies between requests we need to pass a common <code>CookieContainer</code> to each request.</p>
<p>Http headers may also be added to the request using another overload but this will not be handled here. Those that need to do such a thing will easily understand the implementation.</p>
<pre class="brush:c#;"> [Test]
  public void Using_CookieContainer_With_CreatePostJsonApp()
  {

      JavaScriptSerializer jsSerializer = new JavaScriptSerializer();

      string[] jsonEndpoints = new[] { &quot;AjaxService.svc&quot;, &quot;ScriptService.asmx&quot;, &quot;Default.aspx&quot; };
      List&lt;string&gt; failures = new List&lt;string&gt;();
      foreach (string address in jsonEndpoints)
      {
          try
          {

              // a container to store our cookies
              CookieContainer cookies = new CookieContainer();

              // the SessionId to verify cookies/session are working as expected
              string sessionId;

              // pass the CookieContainer in to catch any cookies set by the server
              using (var response = RequestFactory.CreatePostJsonApp(NormalizeUri(address + &quot;/PutSessionVar&quot;), new { input = &quot;foo&quot; }, cookies).GetResponse().GetResponseStream())
              {
                  Result result = jsSerializer.CleanAndDeserialize&lt;Result&gt;(response.Text());
                  Assert.AreEqual(&quot;foo&quot;, result.Value);

                  sessionId = result.Session;
              }

              // get the var
              // pass the same CookieContainer in with the next request as it now contains the session cookie 
              using (var response = RequestFactory.CreatePostJsonApp(NormalizeUri(address + &quot;/GetSessionVar&quot;), null, cookies).GetResponse().GetResponseStream())
              {
                  Result result = jsSerializer.CleanAndDeserialize&lt;Result&gt;(response.Text());
                  Assert.AreEqual(&quot;foo&quot;, result.Value);
                  Assert.AreEqual(sessionId, result.Session);
              }
          }
          catch (Exception ex)
          {
              failures.Add(string.Format(&quot;Endpoint {0} failed {1} with {2}&quot;, address, &quot;CreatePostJsonApp&quot;, ex.Message));
          }
      }

      if (failures.Count &gt; 0)
      {
          Assert.Fail(string.Join(&quot;\r\n&quot;, failures.ToArray()));
      }
  }
</pre>
<h3>Using CreateFilePost To Upload Stream</h3>
<p>The primary <code>CreateFilePost</code> method uploads a <code>Stream</code> to an Http form handler.</p>
<p>Arguments:</p>
<ul>
    <li><code><strong>requestUri</strong> - string or Uri</code><br />
    Absolute Uri of resource<br />
    </li>
    <li><code><strong>postData</strong> - NameValueCollection</code><br />
    A NameValueCollection containing form fields to post with file data<br />
    </li>
    <li><code><strong>fileData</strong> - Stream</code><br />
    An open, positioned stream containing the file data.<br />
    </li>
    <li><code><strong>fileName</strong> - string</code><br />
    A name to assign to the file data and from which to infer fileContentType if necessary.<br />
    </li>
    <li><code><strong>fileContentType</strong> - string</code><br />
    Optional. If omitted, the registry is queried using fileName. If content type is not available from registry, application/octet-stream will be submitted.<br />
    </li>
    <li><code><strong>fileFieldName</strong> - string</code><br />
    Optional. A identifier to represent the name of the input element supplying the data. If ommited the value file will be submitted.<br />
    </li>
    <li><code><strong>cookies</strong> - CookieCollection</code><br />
    Optional. Sharing a CookieCollection between requests is required to maintain session state, FormsAuthentication tickets and other cookies.<br />
    </li>
    <li><code><strong>headers</strong> - NameValueCollection</code><br />
    Optional. Http headers to be added to the request.</li>
</ul>
<pre class="brush:c#;">  [Test]
  public void Using_CreateFilePost_To_Upload_Data_From_Memory()
  {
      JavaScriptSerializer jsSerializer = new JavaScriptSerializer();

      var uploadResultPrototype = new
          {
              postData = default(string),
              fileFieldName = default(string),
              fileName = default(string),
              fileContentType = default(string),
              fileContentLength = default(int),
          };

      Uri requestUri = NormalizeUri(&quot;UploadHandler.ashx&quot;);
      NameValueCollection postData = new NameValueCollection
          {
              {&quot;field1&quot;, &quot;field1Value&quot;},
              {&quot;chkBoxGrp1&quot;, &quot;a&quot;},
              {&quot;chkBoxGrp1&quot;, &quot;b&quot;}
          };


      const string content = &quot;some text&quot;;
      Stream fileData = new MemoryStream(Encoding.UTF8.GetBytes(content));
      const string fileName = &quot;TextFileFromMemory.txt&quot;;
      const string fileContentType = &quot;text/plain&quot;;
      const string fileFieldName = &quot;fileField&quot;;

      // am glossing over the use of cookies and headers as this has already been covered.

      HttpWebRequest request = RequestFactory.CreateFilePost(requestUri, postData, fileData, fileName, fileContentType, fileFieldName, null, null);

      try
      {
          using (Stream stream = request.GetResponse().GetResponseStream())
          {
              var response = jsSerializer.CleanAndDeserialize(stream.Text(), uploadResultPrototype);
              Assert.AreEqual(9, response.fileContentLength);
              Assert.AreEqual(&quot;text/plain&quot;, response.fileContentType);
              Assert.AreEqual(&quot;fileField&quot;, response.fileFieldName);
              Assert.AreEqual(&quot;TextFileFromMemory.txt&quot;, response.fileName);
              Assert.AreEqual(&quot;field1=field1Value\r\nchkBoxGrp1=a,b\r\n&quot;, response.postData);


          }
      }
      catch (WebException ex)
      {
          throw WebRequestException.Create(ex);
      }


      // just send data and filename

      fileData.Position = 0;
      HttpWebRequest request2 = RequestFactory.CreateFilePost(requestUri, fileData, fileName);

      try
      {
          using (Stream stream = request2.GetResponse().GetResponseStream())
          {
              var response = jsSerializer.CleanAndDeserialize(stream.Text(), uploadResultPrototype);
              Assert.AreEqual(9, response.fileContentLength);
              Assert.AreEqual(&quot;text/plain&quot;, response.fileContentType);
              Assert.AreEqual(&quot;file&quot;, response.fileFieldName);
              Assert.AreEqual(&quot;TextFileFromMemory.txt&quot;, response.fileName);
          }
      }
      catch (WebException ex)
      {
          throw WebRequestException.Create(ex);
      }

      
  }
</pre>
<h3>Using CreateFilePost To Upload File</h3>
<p>The secondary base <code>CreateFilePost</code> method accepts a physical file path, open the file stream and calls the primary <code>CreateFilePost</code> method.</p>
<p><strong>Arguments:</strong></p>
<ul>
    <li><code><strong>requestUri</strong> - string or Uri</code><br />
    Absolute Uri of resource<br />
    </li>
    <li><code><strong>postData</strong> - NameValueCollection</code><br />
    A <code>NameValueCollection</code> containing form fields to post with file data<br />
    </li>
    <li><code><strong>fileName</strong> - string</code><br />
    The physical path of the file to upload<br />
    </li>
    <li><code><strong>fileContentType</strong> - fileContentType - string</code><br />
    Optional. If omitted, the registry is queried using <code>fileName</code>. If content type is not available from registry, application/octet-stream will be submitted.<br />
    </li>
    <li><code><strong>fileFieldName</strong> - string</code><br />
    Optional. A identifier to represent the name of the input element supplying the data. If ommited the value file will be submitted.<br />
    </li>
    <li><code><strong>cookies</strong> - CookieCollection</code><br />
    Optional. Sharing a <code>CookieCollection</code> between requests is required to maintain session state, FormsAuthentication tickets and other cookies.<br />
    </li>
    <li><code><strong>headers</strong> - NameValueCollection</code><br />
    Optional. Http headers to be added to the request.</li>
</ul>
<pre class="brush:c#;">  [Test]
  public void Using_CreateFilePost_To_Upload_File_From_Disk()
  {
      JavaScriptSerializer jsSerializer = new JavaScriptSerializer();
      var uploadResultPrototype = new
      {
          postData = default(string),
          fileFieldName = default(string),
          fileName = default(string),
          fileContentType = default(string),
          fileContentLength = default(int),
      };


      Uri requestUri = NormalizeUri(&quot;UploadHandler.ashx&quot;);
      NameValueCollection postData = new NameValueCollection
          {
              {&quot;field1&quot;, &quot;field1Value&quot;},
              {&quot;chkBoxGrp1&quot;, &quot;a&quot;},
              {&quot;chkBoxGrp1&quot;, &quot;b&quot;}
          };

      string fileName = Path.GetFullPath(&quot;TextFileFromDisk.txt&quot;);
      const string fileContentType = &quot;text/plain&quot;;
      const string fileFieldName = &quot;fileField&quot;;


      var request = RequestFactory.CreateFilePost(requestUri, postData, fileName, fileContentType, fileFieldName, null, null);


      try
      {
          using (Stream stream = request.GetResponse().GetResponseStream())
          {
              var response = jsSerializer.CleanAndDeserialize(stream.Text(), uploadResultPrototype);
              Assert.AreEqual(12, response.fileContentLength); // content length is text length + BOM
              Assert.AreEqual(&quot;text/plain&quot;, response.fileContentType);
              Assert.AreEqual(&quot;fileField&quot;, response.fileFieldName);
              Assert.AreEqual(&quot;TextFileFromDisk.txt&quot;, response.fileName);
              Assert.AreEqual(&quot;field1=field1Value\r\nchkBoxGrp1=a,b\r\n&quot;, response.postData);


          }
      }
      catch (WebException ex)
      {
          throw WebRequestException.Create(ex);
      }


      // just send data and filename


      HttpWebRequest request2 = RequestFactory.CreateFilePost(requestUri, fileName);

      try
      {
          using (Stream stream = request2.GetResponse().GetResponseStream())
          {
              var response = jsSerializer.CleanAndDeserialize(stream.Text(), uploadResultPrototype);
              Assert.AreEqual(12, response.fileContentLength);// content length is text length + BOM
              Assert.AreEqual(&quot;text/plain&quot;, response.fileContentType);
              Assert.AreEqual(&quot;file&quot;, response.fileFieldName);
              Assert.AreEqual(&quot;TextFileFromDisk.txt&quot;, response.fileName);
          }
      }
      catch (WebException ex)
      {
          throw WebRequestException.Create(ex);
      }

  }
</pre>
<h3>Conclusion</h3>
<p>With the information and patters presented above you should now be able to quickly and easily bolster your projects with tests that prove that your endpoints are behaving themselves.</p>
<p>In the main <code>HttpLib</code> tests you will find a more thorough treatment of each class and method in the library.</p>
<p>The latest source and tests can be found @ <a target="_blank" href="http://salient.codeplex.com">http://salient.codeplex.com</a></p>
    <h3>What&#39;s Next?</h3>
    <p>Next week I will present a similar walkthrough using
        <a href="http://cassinidev.codeplex.com">http://cassinidev.codeplex.com</a> to 
        demonstrate more atomic control of the web server. Some of the features of 
        CassiniDev that make it a more capable host for testing are:</p>
    <ul>
        <li>Port scanning to eliminate collisions</li>
        <li>Explicit or Idle time shutdown</li>
        <li>Can run as a headless console application.</li>
        <li>Provides a test fixture quite similar to the WebDevFixture. ;-)</li>
        <li>Not limited to localhost, enables operation on any IP, internal or external and 
            supports host names.</li>
    </ul>
    <p>
        Until then.</p>
<h3>History</h3>
<ul>
    <li>04/15/2010 - Initial post</li>
</ul>
<p>&nbsp;</p>
</body>
</html>
